# Angular 8: Reactive Forms
1.	These are also called as Model-driven forms. We need to import `ReactiveFormsModule` (from `@angular/forms`) to work with these. They are called as reactive, because they expose the observable-based API. These start the life in the component class and the template is later hooked to this code-generated form.
2.	Angular has `FormControl`, `FormArray`, and `FormGroup` classes, which all derive from `AbstractControl` base class. Basically, a reactive form is a `FormGroup`. So we create a `FormGroup` and to the constructor pass the config object, which contains a list of `FormControls`. Please refer to the reactive form in polling-app.
3.	Every `FormControl` constructor takes the default value, array of synchronous validators, and an array of asynchronous validators. These validators are functions that have to conform to the specific signature. Please refer to the project.
4.	Async validators take an abstract control as the param and return either `Promise<any>` or `Observable<any>`. Refer to the async validators and this binding in the project.
5.	Once the form is created in the code, we create a normal html form in the template. Since the formgroup is created in the code (say myForm), it should be assigned to the formGroup built-in directive. (ngSubmit)="submitHandler()" works just fine. So we have the form tag as: `<form [formGroup]="myForm" (ngSubmit)="submitHandler()">`
6.	Now, every input element will have to apply `formControlName="myForm.control"`. No validation directives in the template are applied, as it is already done in the code.
7.	No need to export the control as in the case of a T-D form. the errors are written directly to the FormControl of the FormGroup. Please refer to R-Form template for more information about displaying the errors.