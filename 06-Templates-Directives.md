# Angular 8: More on Templates and Attribute Directives
1. When we declare a template variable for an element, it could be used in the code as an `ElementRef` or `ComponentRef` using `@ViewChild('templateReference')` decorator for the field
2. But this element is hooked to the code after view is initalized. If we implement `AfterViewInit` interface (`ngAfterViewInit` lifecycle hook), Angular runtime will initialize the element to the field. Please refer to the `angular-view` project.
3. `OnChanges` interface is implemented (`ngOnChanges` lifecycle hook) to know when the input (`@Input() x`) properties to a components are changed. This method is called with a useful argument that tells us the previous and current values.
4. `DoCheck` interface is implemented (`ngDoCheck` lifecycle hook) to know when the data-bound elements trigger any change (such as property-bound field changes or some locally hooked event such as `input` or `click` happens). Angular change detection mechanism triggers this lifecycle hook and it is called often if the binding is non-trivial. Abusing this hook slows the performance.
5. A directive in Angular can be considered as a component without a template. We create a directive by `ng g d xyz`. These directives are called as **attribute directives**, unless we make them **structural** by advanced techniques. Directive is applied to a element or a component such as `<h1 appCustomDirective>Header</h1>`. Then the component or element is called as the host for the directive. Directives are decorated with `@Directive({...})`. Angular prescribes the directive `selector` should be prefixed with app such as `appCustomDirective`. Please avoid using the selectors that are short and common such as `readonly`, `bold`, `value`, `name`, etc. They can conflict with native HTML attributes. Directives are created per application. If there are say 4 applications, then there are 4 instances of the particular directive class. Directives are initalized by the Angular runtime when the view is rendered. Therefore, at the time of directive construction, the host element is ready. This can be used for dependency injection. The host element can be injected in the constructor.
6. A directive mainly interacts with its host element by two ways:
	1. `@HostBinding('attribute') prop/getter` >> For example `@HostBinding('className') css = 'font-weight-bold';`
	2. `@HostListener('event', "['$event']") method(arg) {...}` >> For example `@HostListener('dblclick', "['$event']") handler(arg) {console.log(args);}`